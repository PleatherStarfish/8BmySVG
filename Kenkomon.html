<html>

<head>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/0.7.1/p5.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/0.7.1/addons/p5.dom.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/0.7.1/addons/p5.sound.min.js"></script>
    <link rel="stylesheet" type="text/css" href="style.css">
</head>

<body>

    <script src="sketch.js"></script>

    <!-- Test SVG -->
    <div>
    <svg version="1.1" id="Layer_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"
        width="300px" height="300px" viewBox="0 0 300 300" enable-background="new 0 0 300 300" xml:space="preserve">
        <g>
            <path id="svgpath1" fill="none" stroke="#000000" stroke-miterlimit="10" d="M268.334,182.997c0,55.514-53.334,98.002-118.334,98.002
    c-70.333,0-118.334-51.258-118.334-98.747c0-71.73,45.493-167.464,117.218-167.464S268.334,111.266,268.334,182.997z" />
            <polyline id="svgpath2" fill="none" stroke="#000000" stroke-miterlimit="10" points="85,209.007 111.667,201.007 146.333,209.007 171,201.007
    185,209.007 199.667,201.007 218.333,209.007 " />
            <polyline id="svgpath3" fill="none" stroke="#000000" stroke-miterlimit="10" points="84.33,100.655 96.33,81.321 116.996,81.321 127.667,94.657
    " />
            <line id="svgpath4" fill="none" stroke="#000000" stroke-miterlimit="10" x1="106.669" y1="105.666" x2="106.669" y2="126.332" />
            <line id="svgpath5" fill="none" stroke="#000000" stroke-miterlimit="10" x1="180.333" y1="105.666" x2="232.333" y2="105.666" />
        </g>
    </svg>
    </div>


    <script>
        // TODO: Extract SVG creation class to general class for drawing SVG into pixels
        // How it works
        // (1) Create array for canvas
        // (2) Create an array for the drawn SVG object, by walking along it
        // (3a) Draw the white pixel squares
        // (3b) Compare the arrays from (1) and (2),
        // if the drawn SVG object coordinate falls within the canvas square,
        // make that fill a black square

        //TODO: need to iterate through ALL svg vectors and push these onto the 'black square' array

        let canvArray = [];
        let eggArray = [];
        const pathIDs = ["svgpath1", "svgpath2", "svgpath3", "svgpath4", "svgpath5"];
        // let pathVariables = [];
        // let pathLengths = [];



        class SVG_Multipath {
          // Class returns an array of all points in an SVG

          constructor(listOfPathIDs) {
            this.pathIDs = listOfPathIDs;
            this.pathVariables = [];
            this.pathLengths = [];
            this.pathArray = [];
          }

          path_Variables_Array() {
            for (let n = 0; n < this.pathIDs.length; n++) {
                this.pathVariables.push(document.getElementById(this.pathIDs[n]));
              }
          }
          path_Lengths_Array() {
              for (let n = 0; n < this.pathIDs.length; n++) {
                  this.pathLengths.push(this.pathVariables[n].getTotalLength());
                }
          }
          svg_Path_Length() {
            this.path_Variables_Array();
            this.path_Lengths_Array();
              for (let n = 0; n < this.pathIDs.length; n++) {
                for (let m = 0; m < this.pathLengths[n]; m++) {
                    const path_x = this.pathVariables[n].getPointAtLength(m).x;
                    const path_y = this.pathVariables[n].getPointAtLength(m).y;
                    this.pathArray.push([path_x, path_y]);
              }
            }
          }
          svg_Array() {
            this.svg_Path_Length();
            return this.pathArray;
          }
        }
        //
        //
        //
        // // Put all the paths into an array
        // function pathVariablesArray() {
        //     for (let n = 0; n < pathIDs.length; n++) {
        //         pathVariables.push(document.getElementById(pathIDs[n]));
        //       }
        // }
        //
        // // Put the lengths of all the paths into another array
        // function pathLengthsArray() {
        //     for (let n = 0; n < pathIDs.length; n++) {
        //         pathLengths.push(pathVariables[n].getTotalLength());
        //       }
        // }
        //
        // // The outer "for-loop" iterates over each SVG path by ID in "pathIDs"
        // // The Innner "for-loop" then adds all points along that path to none
        // // massive array called "pathArray."
        // function svgPathLength(path, length, pathArray) {
        //   pathVariablesArray()
        //   pathLengthsArray()
        //     for (let n = 0; n < pathIDs.length; n++) {
        //       for (let m = 0; m < length[n]; m++) {
        //           const path_x = path[n].getPointAtLength(m).x;
        //           const path_y = path[n].getPointAtLength(m).y;
        //           pathArray.push([path_x, path_y]);
        //       }
        //     }
        // }

        function setup() {
            createCanvas(300, 300);

            // Create a 300px x 300px canvas of 8-bit style squares and add all those coordinates to an array
            let x = 0;
            while (x < 30) {
                for (var i = 0; i < 30; i++) {
                    xCoOrd = i * 10;
                    yCoOrd = x * 10;
                    canvArray.push([xCoOrd, yCoOrd]);
                }
                x += 1
            }

            // Create an array of all points in the SVG path
            // svgPathLength(pathVariables, pathLengths, eggArray);

            const p = new SVG_Multipath(pathIDs, eggArray);
            eggArray = p.svg_Array();
            // eggArray.push(p.svg_Array());
            // console.log(eggArray);

        }

        function draw() {

            background(220);
            noStroke();

            for (let j = 0; j < canvArray.length; j++) {
                fill(255);
                let rect_x = canvArray[j][0];
                let rect_y = canvArray[j][1];
                // "startingPoint" is always the point in the SVG path that we
                // last checked, meaning that we don't loop through the whole
                // array every time we render the squares
                let startingPoint = 0;
                for (let v = startingPoint; v < eggArray.length; v++) {
                    let egg_x = eggArray[v][0];
                    let egg_y = eggArray[v][1];
                    // If the point falls within the coordinates of the box,
                    // then change the fill of that box to black.
                    if (((egg_x > rect_x)&& (egg_x < (rect_x+9))) &&
                        ((egg_y > rect_y) && (egg_y < (rect_y + 9)))) {
                        fill(0);
                        startingPoint = v;
                    }
                }
                rect(rect_x, rect_y, 9, 9);
            }

        }


      </script>
</body>

</html>
